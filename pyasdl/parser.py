#!/usr/bin/env python3.8
# @generated by pegen from pyasdl/static/asdl.gram

import ast
import sys
import tokenize
from typing import Any, List, Optional, Union

from pegen.parser import Parser, logger, memoize, memoize_left_rec
from pyasdl.grammar import (
    Constructor,
    Field,
    FieldQualifier,
    Module,
    Product,
    Sum,
    Type,
)

TypeList = List[Type]
FieldList = List[Field]
ConstructorList = List[Constructor]
ProductOrSum = Union[Product, Sum]


class GeneratedParser(Parser):
    @memoize
    def start(self) -> Optional[Module]:
        # start: 'module' NAME NEWLINE? "{" definitions "}"
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect("module"))
            and (name := self.name())
            and (opt := self.expect("NEWLINE"),)
            and (literal_1 := self.expect("{"))
            and (body := self.definitions())
            and (literal_2 := self.expect("}"))
        ):
            return Module(name.string, body)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def definitions(self) -> Optional[TypeList]:
        # definitions: definition definitions | definition
        mark = self.mark()
        cut = False
        if (definition := self.definition()) and (
            definitions := self.definitions()
        ):
            return [definition] + definitions
        self.reset(mark)
        if cut:
            return None
        cut = False
        if definition := self.definition():
            return [definition]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def definition(self) -> Optional[Type]:
        # definition: NAME "=" (sum | product)
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and (literal := self.expect("="))
            and (define := self._tmp_1())
        ):
            return Type(name.string, define)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def sum(self) -> Optional[Sum]:
        # sum: sum_body attributes?
        mark = self.mark()
        cut = False
        if (sum_body := self.sum_body()) and (attrs := self.attributes(),):
            return Sum(sum_body, attrs or [])
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def product(self) -> Optional[Product]:
        # product: fields attributes?
        mark = self.mark()
        cut = False
        if (a := self.fields()) and (attrs := self.attributes(),):
            return Product(a, attrs or [])
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def sum_body(self) -> Optional[ConstructorList]:
        # sum_body: constructor !"|" | "|".constructor+
        mark = self.mark()
        cut = False
        if (constructor := self.constructor()) and self.negative_lookahead(
            self.expect, "|"
        ):
            return [constructor]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if constructors := self._gather_2():
            return constructors
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def constructor(self) -> Optional[Constructor]:
        # constructor: NAME fields?
        mark = self.mark()
        cut = False
        if (name := self.name()) and (fields := self.fields(),):
            return Constructor(name.string, fields)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def fields(self) -> Optional[FieldList]:
        # fields: "(" fields_body ")"
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect("("))
            and (fields_body := self.fields_body())
            and (literal_1 := self.expect(")"))
        ):
            return fields_body
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def fields_body(self) -> Optional[FieldList]:
        # fields_body: field !"," | ",".field+
        mark = self.mark()
        cut = False
        if (field := self.field()) and self.negative_lookahead(
            self.expect, ","
        ):
            return [field]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if fields := self._gather_4():
            return fields
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def field(self) -> Optional[Field]:
        # field: NAME field_qualifier? NAME
        mark = self.mark()
        cut = False
        if (
            (type := self.name())
            and (qualifier := self.field_qualifier(),)
            and (name := self.name())
        ):
            return Field(type.string, name.string, qualifier)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def field_qualifier(self) -> Optional[FieldQualifier]:
        # field_qualifier: "?" | "*"
        mark = self.mark()
        cut = False
        if literal := self.expect("?"):
            return FieldQualifier.OPTIONAL
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("*"):
            return FieldQualifier.SEQUENCE
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def attributes(self) -> Optional[FieldList]:
        # attributes: "attributes" fields
        mark = self.mark()
        cut = False
        if (literal := self.expect("attributes")) and (
            fields := self.fields()
        ):
            return fields
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _tmp_1(self) -> Optional[Any]:
        # _tmp_1: sum | product
        mark = self.mark()
        cut = False
        if sum := self.sum():
            return [sum]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if product := self.product():
            return [product]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: "|" constructor
        mark = self.mark()
        children = []
        cut = False
        while (literal := self.expect("|")) and (elem := self.constructor()):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _gather_2(self) -> Optional[Any]:
        # _gather_2: constructor _loop0_3
        mark = self.mark()
        cut = False
        if (elem := self.constructor()) and (seq := self._loop0_3()):
            return [elem] + seq
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: "," field
        mark = self.mark()
        children = []
        cut = False
        while (literal := self.expect(",")) and (elem := self.field()):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _gather_4(self) -> Optional[Any]:
        # _gather_4: field _loop0_5
        mark = self.mark()
        cut = False
        if (elem := self.field()) and (seq := self._loop0_5()):
            return [elem] + seq
        self.reset(mark)
        if cut:
            return None
        return None


if __name__ == "__main__":
    from pegen.parser import simple_parser_main

    simple_parser_main(GeneratedParser)
